diff --git a/internal/core/mysis.go b/internal/core/mysis.go
index original..modified 100644
--- a/internal/core/mysis.go
+++ b/internal/core/mysis.go
@@ -196,12 +196,22 @@ func (m *Mysis) State() MysisState {
 
 func (m *Mysis) Start() error {
 	a := m
+	log.Debug().
+		Str("mysis", a.name).
+		Str("mysis_id", a.id).
+		Msg("=== START CALLED ===")
+	
 	a.mu.Lock()
+	log.Debug().
+		Str("mysis", a.name).
+		Str("current_state", string(a.state)).
+		Bool("has_cancel", a.cancel != nil).
+		Bool("has_ctx", a.ctx != nil).
+		Msg("Start: acquired lock, checking state")
+	
 	if a.state == MysisStateRunning {
 		a.mu.Unlock()
+		log.Debug().Str("mysis", a.name).Msg("Start: already running, returning error")
 		return fmt.Errorf("mysis already running")
 	}
 
@@ -209,7 +219,12 @@ func (m *Mysis) Start() error {
 
 	// If restarting from errored state, cleanup any existing context/goroutine
 	if oldState == MysisStateErrored && a.cancel != nil {
+		log.Debug().
+			Str("mysis", a.name).
+			Msg("Start: restarting from errored, cancelling old context")
 		a.cancel() // Cancel old context
 		a.mu.Unlock()
+		
+		log.Debug().Str("mysis", a.name).Msg("Start: waiting for old goroutine to exit")
 		// Wait for old goroutine to exit
 		done := make(chan struct{})
@@ -219,16 +234,27 @@ func (m *Mysis) Start() error {
 			a.turnMu.Unlock()
 		}()
 		select {
 		case <-done:
+			log.Debug().Str("mysis", a.name).Msg("Start: old goroutine exited cleanly")
 			// Old goroutine exited
 		case <-time.After(2 * time.Second):
 			log.Warn().Str("mysis", a.name).Msg("Timeout waiting for errored goroutine to exit")
 		}
 		a.mu.Lock()
+		log.Debug().Str("mysis", a.name).Msg("Start: re-acquired lock after cleanup")
 	}
 
 	a.mu.Unlock()
+	log.Debug().Str("mysis", a.name).Msg("Start: creating new context")
 
 	// Create context first (before any state changes)
 	ctx, cancel := context.WithCancel(context.Background())
+	log.Debug().
+		Str("mysis", a.name).
+		Msg("Start: context created, updating store")
 
 	// Update store BEFORE changing in-memory state
@@ -236,10 +262,17 @@ func (m *Mysis) Start() error {
 	if err := a.store.UpdateMysisState(a.id, store.MysisStateRunning); err != nil {
 		cancel() // Clean up context since we're not starting
+		log.Error().
+			Err(err).
+			Str("mysis", a.name).
+			Msg("Start: failed to update store")
 		return fmt.Errorf("failed to update state in store: %w", err)
 	}
 
+	log.Debug().Str("mysis", a.name).Msg("Start: store updated, updating in-memory state")
+
 	// Now that store update succeeded, update in-memory state
 	a.mu.Lock()
@@ -250,6 +283,12 @@ func (m *Mysis) Start() error {
 	a.cancel = cancel
 	a.mu.Unlock()
 
+	log.Debug().
+		Str("mysis", a.name).
+		Str("old_state", string(oldState)).
+		Str("new_state", string(MysisStateRunning)).
+		Msg("Start: state updated, launching goroutine")
+
 	// Add system prompt if this is the first time starting (no memories yet)
 	count, err := a.store.CountMemories(a.id)
 	if err == nil && count == 0 {
@@ -273,12 +312,27 @@ func (m *Mysis) Start() error {
 // Stop halts the mysis processing loop.
 func (m *Mysis) Stop() error {
 	a := m
+	log.Debug().
+		Str("mysis", a.name).
+		Str("mysis_id", a.id).
+		Msg("=== STOP CALLED ===")
+	
 	a.mu.Lock()
+	log.Debug().
+		Str("mysis", a.name).
+		Str("current_state", string(a.state)).
+		Bool("has_cancel", a.cancel != nil).
+		Msg("Stop: acquired lock, checking state")
+	
 	if a.state != MysisStateRunning {
 		a.mu.Unlock()
+		log.Debug().
+			Str("mysis", a.name).
+			Str("state", string(a.state)).
+			Msg("Stop: not running, returning early")
 		return nil
 	}
 
+	log.Debug().Str("mysis", a.name).Msg("Stop: cancelling context")
 	if a.cancel != nil {
 		a.cancel()
 	}
@@ -289,6 +343,7 @@ func (m *Mysis) Stop() error {
 	done := make(chan struct{})
 	go func() {
 		a.turnMu.Lock()
+		log.Debug().Str("mysis", a.name).Msg("Stop: acquired turnMu")
 		close(done)
 		a.turnMu.Unlock()
 	}()
@@ -296,14 +351,26 @@ func (m *Mysis) Stop() error {
 	select {
 	case <-done:
+		log.Debug().Str("mysis", a.name).Msg("Stop: turn finished successfully")
 		// Turn finished successfully
 	case <-time.After(5 * time.Second):
 		log.Warn().Str("mysis", a.name).Msg("Stop timeout - forcing shutdown")
 		// Continue with cleanup even if turn didn't complete
 	}
 
 	a.mu.Lock()
+	log.Debug().
+		Str("mysis", a.name).
+		Str("state", string(a.state)).
+		Msg("Stop: re-acquired lock, checking state again")
+	
 	if a.state != MysisStateRunning {
 		a.mu.Unlock()
+		log.Warn().
+			Str("mysis", a.name).
+			Str("state", string(a.state)).
+			Msg("Stop: state changed during wait (possible race)")
 		return nil
 	}
@@ -770,10 +837,29 @@ func (m *Mysis) formatToolCallsForStorage(calls []provider.ToolCall) string {
 // This method ensures proper state machine compliance by transitioning to MysisStateErrored.
 func (m *Mysis) setError(err error) {
 	a := m
+	log.Debug().
+		Str("mysis", a.name).
+		Str("mysis_id", a.id).
+		Err(err).
+		Msg("=== SETERROR CALLED ===")
+	
 	a.mu.Lock()
+	log.Debug().
+		Str("mysis", a.name).
+		Str("current_state", string(a.state)).
+		Err(err).
+		Msg("setError: acquired lock")
+	
+	// RACE CONDITION CHECK: Don't overwrite stopped state with errored
+	if a.state == MysisStateStopped {
+		a.mu.Unlock()
+		log.Debug().
+			Str("mysis", a.name).
+			Err(err).
+			Msg("setError: ignoring error because mysis was stopped")
+		return
+	}
 
-	oldState := a.state
+	log.Debug().
+		Str("mysis", a.name).
+		Str("old_state", string(a.state)).
+		Str("new_state", string(MysisStateErrored)).
+		Err(err).
+		Msg("setError: transitioning to errored state")
+	
+	oldState := a.state
 	a.lastError = err
 	a.state = MysisStateErrored
